import bcrypt from 'bcryptjs';
import knex from 'knex';
import xss from 'xss';

const UsersService = {
  usersTable: 'users',
  /**
   * 
   * @param {knex} db - knex db connection object
   * @param {string} username - username string to check against db
   * @returns {Promise<boolean>} True if username is already in db
   */
  async usernameTaken(db, username) {
    const nameInDB = await db(this.usersTable)
      .where({ username })
      .first()
    return Boolean(nameInDB);
  },
  /**
   *  Given a db connection and a new user object, add it to the table 'users'
   * @param {knex} db - knex db connection object
   * @param {{ 
   * user_id: number, username: string, password: string, date_created: string 
   * }} newUser - User object with keys correspoding with columns in 'users' table
   * @return {Promise<{
   * user_id: number, username: string, password: string, date_created: string,
   * }>}  The inserted user object
   */
  async insertUser(db, newUser) {
    const user = await db
      .insert(newUser)
      .into(this.usersTable)
      .returning('*')

    return user;
  },
  /**
   * Use bcrypt.hash to generate hash from given password string
   * @param {string} password password string provided by user
   * @return {Promise<string>} salt and hash string generated by bcrypt
   */
  async hashPassword(password) {
    const hash = await bcrypt.hash(password, 12);
    return hash;
  },
  /**
   * Sanitize and parse database values before sending them to client
   * @param {{user_id: number, username: string, date_created: string}} user - User object from database 
   * @returns {{user_id: number, username: string, date_created: string}} User object formatted for transfer
   */
  serializeUser: (user) => ({
    user_id: user.user_id,
    username: xss(user.username),
    date_created: user.date_created,
  })
}

export default UsersService;